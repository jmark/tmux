.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TMUX-SCRIPTING 1"
.TH TMUX-SCRIPTING 1 "2016-04-25" "tmux" "User Contributed Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
tmux with sensible scripting
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
It was never previously possible in tmux:
.PP
.Vb 7
\&  # Mark the current word in vi\-copy mode
\&  bind\-key \-t vi\-copy M\-Enter tcl {
\&    clear\-selection
\&    previous\-space
\&    begin\-selection
\&    next\-space\-end
\&  }
\&
\&  # Open selection in vim in mini\-window
\&  bind\-key \-t vi\-copy Y tcl {
\&    split\-window \-c [f #{pane_current_path}] \-l 5 "
\&                echo \-n [shell\-quote [copy\-mode\-selection]] | vim \-R \-"
\&  }
\&
\&  # Open selection in emacs in mini\-window
\&  bind\-key \-t emacs\-copy Y tcl {
\&        split\-window \-c [f #{pane_current_path}] \-l 5 "
\&                emacs \-\-insert <(echo \-n [shell\-quote [copy\-mode\-selection]])"
\&  }
\&
\&  #choose from list and switch to git branch
\&  choose\-from\-list {*}[split [exec git branch \-av] "\en"] \-onselect {
\&    exec git checkout [lindex [split [string range $_ 2 end] " "] 0]
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
From now on we have first class turing-complete
config-and-command language support in tmux.
.PP
The choice of the language to use is simple:
(A) \s-1TCL\s0 is easily embeddable and
(B) the syntax is very much like tmux-lang and bash
.PP
All your old configs will continue to work exactly as they did.
.PP
Great products for geeks have full-fledged scripting support:
vim, emacs, and many others.
Tmux is a great thing, too. And now it can be scripted as well.
.PP
\&\s-1TCL\s0 extension leaves tmux fully compatible with TCL-less one.
There's only a new tmux command to execute \s-1TCL\s0 and all tmux
commands are transparently usable from \s-1TCL.\s0 Including 'mode' ones!
.PP
You can assign any number of actions to 'mode' keypresses
and ever write a script of any complexity.
.SH "TMUX EXTENSIONS"
.IX Header "TMUX EXTENSIONS"
The changes against the original tmux are:
.IP "\(bu" 4
New command \fB\f(CB\*(C`tcl\*(C'\fB\fR and alias \fB\f(CB\*(C`t\*(C'\fB\fR in all modes
.Sp
From now on, just use \f(CW\*(C`tcl [command]\*(C'\fR to script in \s-1TCL.\s0
.Sp
If there's a value returned from script/function, it will be displayed
on screen and in message area (\f(CW\*(C`^B ~\*(C'\fR for multiline output).
.IP "\(bu" 4
Global option \fB\f(CB\*(C`tcl\*(C'\fB\fR
.Sp
Numeric (boolean) option to control the mode of command prompt within tmux.
If this evaluates to true (non-zero), the command prompt (\f(CW\*(C`^B :\*(C'\fR) will accept
tcl commands directly.
.IP "\(bu" 4
Global option \fB\f(CB\*(C`have_tcl\*(C'\fB\fR
.Sp
Numeric (boolean) flag that would tell you that \s-1TCL\s0 is present
in this version of tmux.
.Sp
To execute additional \s-1TCL\s0 init config in a compatible way,
add the following to your \fI.tmux.conf\fR:
.Sp
.Vb 1
\&  if\-shell \-F "#{have_tcl}" "tcl source ~/.tmux.tcl"
.Ve
.Sp
and put a file named \fI.tmux.tcl\fR in your home dir.
.Sp
Done so, your config will work in both standard and scriptable versions of tmux.
.SH "TCL MODE"
.IX Header "TCL MODE"
This section presumes tmux is in \s-1TCL\s0 command mode.
.PP
To switch it on, execute this command in tmux, or add to config:
.PP
.Vb 1
\&  set tcl 1
.Ve
.SS "tmux commands access from \s-1TCL\s0"
.IX Subsection "tmux commands access from TCL"
.IP "\(bu" 4
\&\s-1TCL\s0 script has all tmux commands directly accessible in three ways:
.Sp
1. in namespace \fB\f(CB\*(C`::tmux\*(C'\fB\fR
.Sp
2. as global commands
.Sp
3. as global commands prefixed with \fB\f(CB\*(C`:\*(C'\fB\fR
.Sp
For example, the existing tmux command \f(CW\*(C`list\-keys\*(C'\fR has three forms in tcl:
\&\f(CW\*(C`list\-keys\*(C'\fR, \f(CW\*(C`:list\-keys\*(C'\fR and \f(CW\*(C`::tmux::list\-keys\*(C'\fR.
.Sp
Some of tmux commands/aliases use common or built-in \s-1TCL\s0 command names,
such as \f(CW\*(C`if\*(C'\fR, \f(CW\*(C`rename\*(C'\fR, \f(CW\*(C`info\*(C'\fR, \f(CW\*(C`set\*(C'\fR, \f(CW\*(C`source\*(C'\fR, \f(CW\*(C`format\*(C'\fR.
These commands are not added to the global namespace but are
easily accessible with \f(CW\*(C`:\*(C'\fR prefix and under \f(CW\*(C`::tmux\*(C'\fR namespace.
.Sp
The full list of tmux commands can be found in \fItmux\fR\|(1) manual.
.Sp
or (better) way to do it in \s-1TCL\s0 mode:
.Sp
.Vb 1
\&  print {*}[info commands ::tmux::*]
.Ve
.IP "\(bu" 4
Originally, \*(L"mode\*(R" commands are not accessible and not scriptable in tmux.
In \s-1TCL\s0 mode, all of them are first-class commands and can be used as any
other command.
.Sp
In \s-1TCL, \s0\*(L"mode\*(R" commands are accessible in various ways:
.RS 4
.ie n .IP "\fB\fB""::tmux::mode:MODENAME::COMMAND""\fB\fR" 4
.el .IP "\fB\f(CB::tmux::mode:MODENAME::COMMAND\fB\fR" 4
.IX Item "::tmux::mode:MODENAME::COMMAND"
where \s-1MODENAME\s0 is \f(CW\*(C`copy\*(C'\fR or \f(CW\*(C`choice\*(C'\fR.
.Sp
The commands in each mode are implemented on their own in tmux.
The commands that happen to have the same name are internally coded
as separate functions to do different things in modes.
This is why \s-1TCL\s0 has to ensure the current mode is the right one for 'mode' command.
.Sp
This form of \*(L"mode\*(R" command the safest and preferable (less convenient, though).
.ie n .IP "\fB\fB""::tmux::mode::COMMAND""\fB\fR, \fB\fB""::tmux::COMMAND""\fB\fR, global \fB\fB""COMMAND""\fB\fR" 4
.el .IP "\fB\f(CB::tmux::mode::COMMAND\fB\fR, \fB\f(CB::tmux::COMMAND\fB\fR, global \fB\f(CBCOMMAND\fB\fR" 4
.IX Item "::tmux::mode::COMMAND, ::tmux::COMMAND, global COMMAND"
These forms of \*(L"mode\*(R" commands try to auto-detect the current pane mode
and issue the correct \*(L"mode\*(R" command.
.Sp
In a particular mode not all of the commands will actually work because
these namespaces contain the commands for all modes.
.Sp
This form is short and convenient to use but to make sure the command
is good for the current mode, check \f(CW\*(C`::tmux::mode::MODENAME::\*(C'\fR namespace first.
.Sp
Some of 'short' command naming can be confusing.
.Sp
For instance, the command \f(CW\*(C`up\*(C'\fR won't fit for copy-mode but there is a \f(CW\*(C`cursor\-up\*(C'\fR one.
.Sp
If there's a name clash,
\&\*(L"mode\*(R" command will yield to the existing one.
But that can always be found under \f(CW\*(C`::tmux::mode::*\*(C'\fR namespace.
.RE
.RS 4
.Sp
The full list of \*(L"mode\*(R" commands:
.Sp
.Vb 3
\&  print {*}[info commands ::tmux::mode::*] ; # all mode commands
\&  print {*}[info commands ::tmux::mode::copy::*] ; # copy mode cmds
\&  print {*}[info commands ::tmux::mode::choice::*] ; # choice mode cmds
.Ve
.Sp
\&\s-1TODO:\s0 support 'edit' mode, too.
.RE
.SS "New \s-1TCL\s0 mode commands"
.IX Subsection "New TCL mode commands"
.IP "\(bu" 4
\&\fB\f(CB\*(C`format\*(C'\fB\fR, \fB\f(CB\*(C`f\*(C'\fB\fR, \fB\f(CB\*(C`format\-time\*(C'\fB\fR, \fB\f(CB\*(C`ft\*(C'\fB\fR \- get options; format string according to tmux # rules
.Sp
These functions are useful to query settings and options.
.Sp
\&\fB\f(CB\*(C`format\-time\*(C'\fB\fR and \fB\f(CB\*(C`ft\*(C'\fB\fR will first call \f(CW\*(C`strftime\*(C'\fR on their argument.
.Sp
\&\fB\f(CB\*(C`format\*(C'\fB\fR and \fB\f(CB\*(C`f\*(C'\fB\fR just use internal formatting routine.
.Sp
.Vb 1
\&  :f #{pane_current_path}
.Ve
.Sp
Refer to \fItmux\fR\|(1) manpage, \f(CW\*(C`FORMATS\*(C'\fR section.
.Sp
\&\s-1TODO:\s0 document/API for the full list of formattable options
.IP "\(bu" 4
\&\fB\f(CB\*(C`parse\*(C'\fB\fR, \fB\f(CB\*(C`parse2script\*(C'\fB\fR, \fB\f(CB\*(C`parse2eval\*(C'\fB\fR, \fB\f(CB\*(C`parse_exec\*(C'\fB\fR \-
parse and convert tmux config-or-command to \s-1TCL\s0 in various ways:
.RS 4
.ie n .IP "\fB\fB""parse [text]""\fB\fR" 4
.el .IP "\fB\f(CBparse [text]\fB\fR" 4
.IX Item "parse [text]"
return as list of \s-1TCL\s0 commands (for \f(CW\*(C`::tmux\*(C'\fR namespace)
.ie n .IP "\fB\fB""parse2script [text]""\fB\fR" 4
.el .IP "\fB\f(CBparse2script [text]\fB\fR" 4
.IX Item "parse2script [text]"
return as equivalent \s-1TCL\s0 script (for \f(CW\*(C`::tmux\*(C'\fR namespace)
.ie n .IP "\fB\fB""parse2eval [text]""\fB\fR" 4
.el .IP "\fB\f(CBparse2eval [text]\fB\fR" 4
.IX Item "parse2eval [text]"
return as \f(CW\*(C`eval\*(C'\fRable script for global/any namespace
.ie n .IP "\fB\fB""parse_exec [text]""\fB\fR" 4
.el .IP "\fB\f(CBparse_exec [text]\fB\fR" 4
.IX Item "parse_exec [text]"
parse and execute as \s-1TCL\s0
.RE
.RS 4
.RE
.IP "\(bu" 4
\&\fB\f(CB\*(C`output\-of\-txt\*(C'\fB\fR, \fB\f(CB\*(C`output\-of\-list\*(C'\fB\fR \- capture the output of a command
.Sp
Since tmux never wanted to do scripting by itself, the most commands
return data as text output.
.Sp
To be able to deal with it in a programming language, one needs to intercept
the output to put it into a variable or function argument.
.Sp
This set of functions temporarily divert the output while the code block executes
and return the catch:
.Sp
.Vb 8
\&  # put command line in TCL mode
\&  :set tcl
\&  # list keys in the usual way
\&  list\-keys \-t vi\-copy
\&  # return output as a single string
\&  output\-of\-txt { list\-keys \-t vi\-copy }
\&  # return output as list of strings
\&  output\-of\-list { list\-keys \-t vi\-copy }
.Ve
.IP "\(bu" 4
\&\fB\f(CB\*(C`pbcopy\*(C'\fB\fR,
\&\fB\f(CB\*(C`pbpaste\*(C'\fB\fR,
\&\fB\f(CB\*(C`pbcontent\*(C'\fB\fR,
\&\fB\f(CB\*(C`pblist\*(C'\fB\fR \- clipboard functions:
.RS 4
.ie n .IP "\fB\fB""pbcopy {string}""\fB\fR" 4
.el .IP "\fB\f(CBpbcopy {string}\fB\fR" 4
.IX Item "pbcopy {string}"
push the string into clipboard buffers
.ie n .IP "\fB\fB""pbpaste""\fB\fR" 4
.el .IP "\fB\f(CBpbpaste\fB\fR" 4
.IX Item "pbpaste"
not implemented, almost equivalent to \fB\f(CB\*(C`:send\-keys\ {pbcontent}\*(C'\fB\fR
.ie n .IP "\fB\fB""pbcontent""\fB\fR" 4
.el .IP "\fB\f(CBpbcontent\fB\fR" 4
.IX Item "pbcontent"
return content of the topmost clipboard buffer
.ie n .IP "\fB\fB""pblist""\fB\fR" 4
.el .IP "\fB\f(CBpblist\fB\fR" 4
.IX Item "pblist"
return the list of all clipboard buffers
.RE
.RS 4
.RE
.IP "\(bu" 4
copy mode functions:
.Sp
\&\fB\f(CB\*(C`copy\-mode\-get\-cx\*(C'\fB\fR \fB\f(CB\*(C`copy\-mode\-get\-cy\*(C'\fB\fR \- cursor X and Y within the screen
.Sp
\&\fB\f(CB\*(C`copy\-mode\-get\-selx\*(C'\fB\fR \fB\f(CB\*(C`copy\-mode\-get\-sely\*(C'\fB\fR \- coordinates of the other end
of selection, in 'real' coordinates. Selection extents are from sel{x,y} to {cx,cy}.
Contain \fBgarbage\fR is selection is not active.
.Sp
\&\fB\f(CB\*(C`copy\-mode\-is\-selecting\*(C'\fB\fR \- whether selection is active
.Sp
\&\fB\f(CB\*(C`copy\-mode\-get\-oy\*(C'\fB\fR \- 'offset y' for the window. Counts bottom-up.
.Sp
\&\fB\f(CB\*(C`copy\-mode\-get\-hsize\*(C'\fB\fR \- 'history size'. Actually, the limit for \f(CW\*(C`oy\*(C'\fR.
.Sp
\&\fB\f(CB\*(C`copy\-mode\-get\-oy0\*(C'\fB\fR \- convenience function, returns window offset in natural coords, from the top.
.Sp
\&\fB\f(CB\*(C`copy\-mode\-get\-cy0\*(C'\fB\fR \- convenience function, returns y coordinate counting from the topmost buffer position.
.Sp
\&\fB\f(CB\*(C`copy\-mode\-get\-lastcx\*(C'\fB\fR \- tmux: \f(CW\*(C`/* position in last line w/ content */\*(C'\fR
.Sp
\&\fB\f(CB\*(C`copy\-mode\-get\-lastsx\*(C'\fB\fR \- tmux: \f(CW\*(C`/* size of last line w/ content */\*(C'\fR
.IP "\(bu" 4
\&\fB\f(CB\*(C`copy\-mode\-selection\*(C'\fB\fR \- get currently hilighted selection in copy mode
.IP "\(bu" 4
\&\fB\f(CB\*(C`copy\-mode\-screenline [\-sy] SY [\-sx SX] [\-ex EX]\*(C'\fB\fR \- pick line in copy-mode
.Sp
\&\fB\f(CB\*(C`\-sy SY\*(C'\fB\fR \- Y position of the text line (default is current cursor position = [copy\-mode\-get\-cy0] )
.Sp
\&\fB\f(CB\*(C`\-sx SX\*(C'\fB\fR \- starting X position of text in line (default 0)
.Sp
\&\fB\f(CB\*(C`\-ex EX\*(C'\fB\fR \- ending X position of text in line (default \s-1MAX\s0)
.IP "\(bu" 4
\&\fB\f(CB\*(C`print [string ...]\*(C'\fB\fR \- output message
.Sp
Prints message to the messages pane (\f(CW\*(C`^B ~\*(C'\fR).
.IP "\(bu" 4
Status bar functions:
.Sp
\&\fB\f(CB\*(C`status\-msg MESSAGE\*(C'\fB\fR Display message on the bottom status bar
.Sp
\&\fB\f(CB\*(C`status\-msg\-clear\*(C'\fB\fR Reset status bar
.IP "\(bu" 4
\&\fB\f(CB\*(C`using context { script }\*(C'\fB\fR \- execute script in context of another client/session/window/pane
.Sp
Set default context for the commands in \f(CW\*(C`script\*(C'\fR.
.Sp
\&\f(CW\*(C`context\*(C'\fR is a sequence of:
.RS 4
.ie n .IP "\fB\fB""using client {client\-spec} { script }""\fB\fR" 4
.el .IP "\fB\f(CBusing client {client\-spec} { script }\fB\fR" 4
.IX Item "using client {client-spec} { script }"
.PD 0
.ie n .IP "\fB\fB""using session {session\-spec} { script }""\fB\fR" 4
.el .IP "\fB\f(CBusing session {session\-spec} { script }\fB\fR" 4
.IX Item "using session {session-spec} { script }"
.ie n .IP "\fB\fB""using window {window\-spec} { script }""\fB\fR" 4
.el .IP "\fB\f(CBusing window {window\-spec} { script }\fB\fR" 4
.IX Item "using window {window-spec} { script }"
.ie n .IP "\fB\fB""using pane {pane\-spec} { script }""\fB\fR" 4
.el .IP "\fB\f(CBusing pane {pane\-spec} { script }\fB\fR" 4
.IX Item "using pane {pane-spec} { script }"
.RE
.RS 4
.PD
.Sp
For the cpecifications, see \fItmux\fR\|(1) manual, keywords
\&\f(CW\*(C`target\-client\*(C'\fR, \f(CW\*(C`target\-session\*(C'\fR, \f(CW\*(C`target\-window\*(C'\fR, \f(CW\*(C`target\-pane\*(C'\fR.
.Sp
\&\fB\s-1NOTE\s0\fR that this will \fBnot\fR affect the original tmux commands:
they will still require \f(CW\*(C`\-t\*(C'\fR (or whatever) flag to specify the target.
.Sp
\&\fBExamples:\fR
.Sp
.Vb 5
\&  print [f #{pane_current_path}]
\&  print [using pane %1 {f #{pane_current_path}}]
\&  print [using pane :.1 {f #{pane_current_path}}]
\&  print [using window :1 {f #{pane_current_path}}]
\&  print [using client stty01 {f #{pane_current_path}}]
.Ve
.Sp
The cpecifications can nest:
the subsequent cpecifications are considered within the previous ones.
.Sp
.Vb 1
\&  print [using client stty01 window :1 pane %0 {f #{pane_current_path}}]
.Ve
.RE
.IP "\(bu" 4
\&\fB\f(CB\*(C`choose\-from\-list [OPTIONS ...] {ITEMS ...}\*(C'\fB\fR Make choice in choose-mode
.Sp
Switch into 'choice' mode to choose an item from the list.
.Sp
Each item can be preceeded by any number of options.
After the item is added, all options are discarded.
.Sp
Where the commands are applicable, the \f(CW\*(C`tag\*(C'\fR of selected item
is stored in variable \f(CW$_\fR of global namespace.
I.e. for script to read it, in global context just use \f(CW$_\fR.
When executing a function, should use \f(CW$::_\fR
or \f(CW\*(C`global\*(C'\fR command to declare it.
.Sp
The options are:
.RS 4
.ie n .IP "\fB\fB""\-val VALUE""\fB\fR: the following element \s-1IS\s0 the string to display, regardless whether its first character is '\-'." 4
.el .IP "\fB\f(CB\-val VALUE\fB\fR: the following element \s-1IS\s0 the string to display, regardless whether its first character is '\-'." 4
.IX Item "-val VALUE: the following element IS the string to display, regardless whether its first character is '-'."
.PD 0
.ie n .IP "\fB\fB""\-id TAG""\fB\fR | \fB\fB""\-tag TAG""\fB\fR: tag the item. This \s-1ID\s0 will be used to refer to this item and will be saved in $_ when it selected." 4
.el .IP "\fB\f(CB\-id TAG\fB\fR | \fB\f(CB\-tag TAG\fB\fR: tag the item. This \s-1ID\s0 will be used to refer to this item and will be saved in \f(CW$_\fR when it selected." 4
.IX Item "-id TAG | -tag TAG: tag the item. This ID will be used to refer to this item and will be saved in $_ when it selected."
.ie n .IP "\fB\fB""\-cmd {SCRIPT}""\fB\fR: script to execute when this item is selected." 4
.el .IP "\fB\f(CB\-cmd {SCRIPT}\fB\fR: script to execute when this item is selected." 4
.IX Item "-cmd {SCRIPT}: script to execute when this item is selected."
.ie n .IP "\fB\fB""\-selected""\fB\fR: this item is initially selected" 4
.el .IP "\fB\f(CB\-selected\fB\fR: this item is initially selected" 4
.IX Item "-selected: this item is initially selected"
.ie n .IP "\fB\fB""\-selected\-idx NUM""\fB\fR: specify the item index initially selected" 4
.el .IP "\fB\f(CB\-selected\-idx NUM\fB\fR: specify the item index initially selected" 4
.IX Item "-selected-idx NUM: specify the item index initially selected"
.ie n .IP "\fB\fB""\-selected\-id TAG""\fB\fR | \fB\fB""\-selected\-tag TAG""\fB\fR: specify the tag selected" 4
.el .IP "\fB\f(CB\-selected\-id TAG\fB\fR | \fB\f(CB\-selected\-tag TAG\fB\fR: specify the tag selected" 4
.IX Item "-selected-id TAG | -selected-tag TAG: specify the tag selected"
.ie n .IP "\fB\fB""\-onselect {SCRIPT}""\fB\fR: script to execute when the choose-mode ends with a selection" 4
.el .IP "\fB\f(CB\-onselect {SCRIPT}\fB\fR: script to execute when the choose-mode ends with a selection" 4
.IX Item "-onselect {SCRIPT}: script to execute when the choose-mode ends with a selection"
.ie n .IP "\fB\fB""\-oncancel {SCRIPT}""\fB\fR: script to execute when the user cancels choose-mode" 4
.el .IP "\fB\f(CB\-oncancel {SCRIPT}\fB\fR: script to execute when the user cancels choose-mode" 4
.IX Item "-oncancel {SCRIPT}: script to execute when the user cancels choose-mode"
.ie n .IP "\fB\fB""\-list {ITEM ...}""\fB\fR: add this group of elements, apply preceding options" 4
.el .IP "\fB\f(CB\-list {ITEM ...}\fB\fR: add this group of elements, apply preceding options" 4
.IX Item "-list {ITEM ...}: add this group of elements, apply preceding options"
.ie n .IP "\fB\fB""\-\- {ITEM ...}""\fB\fR: no more options. Dashes have no more effect for all remaining arguments." 4
.el .IP "\fB\f(CB\-\- {ITEM ...}\fB\fR: no more options. Dashes have no more effect for all remaining arguments." 4
.IX Item "-- {ITEM ...}: no more options. Dashes have no more effect for all remaining arguments."
.RE
.RS 4
.PD
.Sp
The order of script executed in case something's selected:
.IP "1." 4
Item's \fB\f(CB\*(C`\-cmd\*(C'\fB\fR
.IP "2." 4
Command's \fB\f(CB\*(C`\-onselect\*(C'\fB\fR
.IP "3." 4
Global \fB\f(CB\*(C`choose\-from\-list\-ok\*(C'\fB\fR
.RE
.RS 4
.Sp
All options except 'selected' apply to all \f(CW\*(C`\-list\*(C'\fR'ed items:
.Sp
.Vb 1
\&  choose\-from\-list 1 \-cmd {print "N$_"} 2 3 \-cmd {print "X$_"} \-list {4 5 6}
.Ve
.Sp
In this case \f(CW\*(C`print "N$_"\*(C'\fR applies to \f(CW2\fR
and \f(CW\*(C`print "X$_"\*(C'\fR applies to \f(CW4\fR, \f(CW5\fR, \f(CW6\fR
.RE
.IP "\(bu" 4
\&\fB\f(CB\*(C`get\-list\-keys [\-T table]\*(C'\fB\fR \- get list of keybindings
.Sp
If \f(CW\*(C`\-T table\*(C'\fR option is given,
the bindings for only the specified table is returned.
.Sp
The return format a list of the following values:
.Sp
.Vb 1
\&  table key binding [options]
.Ve
.Sp
The option currently is \f(CW\*(C`\-r\*(C'\fR.
.Sp
The 'binding' is in form of \f(CW\*(C`eval\*(C'\fR\-able script, for example:
.Sp
.Vb 10
\&  prefix C\-l {namespace eval ::tmux {refresh\-client} ; }
\&  prefix H {
\&    if {[f #{pane_current_command}] eq "bash"} {
\&      print {*}[split [read_file ~/.bash_history] "\en"]
\&      history\-bottom
\&      cursor\-upstart\-of\-line
\&    } else {
\&      print "Bash?"
\&    }
\&  }
.Ve
.IP "\(bu" 4
\&\fB\f(CB\*(C`canon\-key key\*(C'\fB\fR \- 'canonical' key representation
.Sp
The key name converted to the one returned by \f(CW\*(C`list\-keys\*(C'\fR.
.Sp
Correct order of \f(CW\*(C`M\-\*(C'\fR, \f(CW\*(C`S\-\*(C'\fR, \f(CW\*(C`C\-\*(C'\fR and canonize some keys name e.g. PgUp writes as 'PPage'.
.IP "\(bu" 4
\&\fB\f(CB\*(C`nop [args ...]\*(C'\fB\fR \- consume all arguments, do nothing, return nothing
.PP
Other helper functions:
.IP "\(bu" 4
\&\fB\f(CB\*(C`tmux [code]\*(C'\fB\fR \- execute code in \f(CW\*(C`::tmux\*(C'\fR namespace
.Sp
Almost the same as \f(CW\*(C`namespace eval ::tmux [code]\*(C'\fR.
.Sp
Intended for easier transition from tmux legacy scripts.
.IP "\(bu" 4
\&\fB\f(CB\*(C`read_file\*(C'\fB\fR, \fB\f(CB\*(C`write_file\*(C'\fB\fR \- read and write the whole file
.IP "\(bu" 4
\&\fB\f(CB\*(C`shell\-quote [string]\*(C'\fB\fR \- quote string to safely pass to shell
.SH "BUILD"
.IX Header "BUILD"
.Vb 4
\&  $ ./autogen.sh
\&  $ ./configure
\&  $ make
\&  $ make install
.Ve
.PP
If a package is installed in another location,
try first specifying \s-1PKG_CONFIG_PATH:\s0
.PP
.Vb 1
\&  $ PKG_CONFIG_PATH=[path to dir with tcl.pl] ./configure
.Ve
.PP
The next step is LIB*_CFLAGS and LIB*_LIBS:
.PP
.Vb 1
\&  $ LIBEVENT_CFLAGS=\-I.../libevent1 LIBEVENT_LIBS="\-L.../libevent1 \-levent" ./configure
.Ve
.PP
And the last way is to use \s-1CPPFLAGS\s0 and \s-1LDFLAGS:\s0
.PP
.Vb 1
\&  $ CPPFLAGS="\-I... \-pipe ..." LDFLAGS="\-L... \-l..." ./configure
.Ve
.PP
Refer to tmux's \fI\s-1README\s0\fR for more build instructions.
.SH "Why"
.IX Header "Why"
\&\fItmux\fR\|(1) is a pretty cool terminal multiplexor with unique features.
.PP
However, one of its key principles looks arguable to me.
This work is done to address the \*(L"use shell for scripting\*(R" one.
.PP
The author's rationale behind this decision was:
(A) freedom from extra dependencies
and (B) avoid inventing and implementing \*(L"yet another\*(R" tool language.
.PP
Unfortunately, they failed at both:
tmux \fBhas\fR its defective 'small config-and-command language';
\&\fBand\fR it depends on the user's shell which limits tmux scripts compatibility to the same shell's users.
.PP
Needless to say, the \fIconfig-and-command tmux small language\fR is not turing-complete,
it has weird symantics, its parsing and behavior differs by 'mode', context and moon phase.
To make any meaningful action, you'd probably need to spawn a shell
and send the command from outside back to your tmux in which case you risk
to fall down into quote hell.
.PP
Even having this limited language, you might find that not all of the features
are available right when you need it (and never gonna fix it <https://github.com/tmux/tmux/issues/310>).
.PP
That's why you want it to get fixed.
.PP
\&\s-1TCL\s0 is suitable both as immediate command language at prompt and
as a common programming language.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fItmux\fR\|(1), \fItcl\fR\|(3tcl), \fItclsh\fR\|(1)
.PP
tmux homepage <http://tmux.github.io/>
.PP
tmux \s-1README\s0 <https://github.com/ershov/tmux/blob/master/README>
.PP
tcl tutorial <http://tcl.tk/man/tcl8.5/tutorial/tcltutorial.html>
.PP
tcl documentation site <http://tcl.tk/doc/>
.SH "AUTHOR"
.IX Header "AUTHOR"
Yury Ershov <mailto:yuriy.ershov@gmail.com>
